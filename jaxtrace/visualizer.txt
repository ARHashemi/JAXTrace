"""
Particle Visualizer Module for JAXTrace

Advanced visualization tools for particle positions, trajectories, and density analysis.
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import seaborn as sns
from typing import Optional, Union, Tuple, List, Callable, Dict
import warnings

# Optional imports
try:
    import plotly.graph_objects as go
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False
    warnings.warn("Plotly not available. Interactive visualizations will be disabled.")

# JAX imports for checking availability
try:
    import jax
    import jax.numpy as jnp
    JAX_AVAILABLE = True
except ImportError:
    JAX_AVAILABLE = False


class ParticleVisualizer:
    """Advanced visualization tools for particle positions, trajectories, and density analysis."""
    
    def __init__(self, 
                 final_positions: Optional[np.ndarray] = None,
                 initial_positions: Optional[np.ndarray] = None,
                 trajectories: Optional[np.ndarray] = None):
        """
        Initialize visualizer with flexible input options.
        
        Args:
            final_positions: Final particle positions (N, 3)
            initial_positions: Initial particle positions (N, 3) 
            trajectories: Full particle trajectories (N, n_steps, 3) - optional
        """
        self.final_positions = final_positions
        self.initial_positions = initial_positions
        self.trajectories = trajectories
        
        # Validate inputs
        if trajectories is not None:
            self.trajectories = trajectories
            if final_positions is None:
                self.final_positions = trajectories[:, -1, :]
            if initial_positions is None:
                self.initial_positions = trajectories[:, 0, :]
        elif final_positions is not None:
            self.final_positions = final_positions
        else:
            raise ValueError("Must provide either final_positions or trajectories")
        
        print(f"ParticleVisualizer initialized with {len(self.final_positions)} particles")
    
    def calculate_density(self,
                         positions: str = 'final',
                         plane: str = 'xy',
                         position: float = 0.0,
                         slab_thickness: float = 0.1,
                         grid_resolution: int = 100,
                         method: str = 'jax_kde',
                         normalize: bool = True,
                         **kwargs) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Calculate particle density using the DensityCalculator from density module.
        
        Args:
            positions: Which positions to use ('initial', 'final')
            plane: Cross-section plane ('xy', 'xz', 'yz')
            position: Position along the third axis for slicing
            slab_thickness: Thickness of the slice
            grid_resolution: Resolution of the evaluation grid
            method: Density estimation method ('jax_kde', 'sph', 'scipy_kde')
            normalize: Whether to normalize density to be dimensionless
            **kwargs: Additional parameters for density estimation methods
            
        Returns:
            X, Y, Z: Meshgrid coordinates and density values
        """
        # Get positions
        if positions == 'final':
            pos_3d = self.final_positions
        elif positions == 'initial':
            if self.initial_positions is None:
                raise ValueError("Initial positions not available")
            pos_3d = self.initial_positions
        else:
            raise ValueError("positions must be 'initial' or 'final'")
        
        # Use the comprehensive DensityCalculator from density module
        try:
            from .density import DensityCalculator
        except ImportError:
            raise ImportError("DensityCalculator not available. Please check density module.")
        
        calculator = DensityCalculator(pos_3d)
        
        return calculator.calculate_density(
            method=method,
            dimensions='2d',
            plane=plane,
            position=position,
            slab_thickness=slab_thickness,
            resolution=grid_resolution,
            normalize=normalize,
            **kwargs
        )
    
    def apply_density_threshold(self, 
                               density: np.ndarray,
                               threshold_percent: float = 25.0,
                               threshold_type: str = 'percent_max') -> np.ndarray:
        """
        Apply threshold to density data, setting values below threshold to NaN.
        
        Args:
            density: Density data array
            threshold_percent: Threshold percentage (0-100)
            threshold_type: Type of threshold ('percent_max', 'percentile', 'absolute')
            
        Returns:
            Thresholded density array
        """
        # Use the utility function from density module
        try:
            from .density import apply_density_threshold
            return apply_density_threshold(density, threshold_percent, threshold_type)
        except ImportError:
            # Fallback implementation
            density_thresh = density.copy()
            
            if threshold_type == 'percent_max':
                max_density = np.max(density[~np.isnan(density)])
                threshold_value = (threshold_percent / 100.0) * max_density
            elif threshold_type == 'percentile':
                threshold_value = np.percentile(density[~np.isnan(density)], threshold_percent)
            elif threshold_type == 'absolute':
                threshold_value = threshold_percent
            else:
                raise ValueError("threshold_type must be 'percent_max', 'percentile', or 'absolute'")
            
            density_thresh[density_thresh < threshold_value] = np.nan
            return density_thresh
    
    def plot_3d_positions(self, 
                         show_initial: bool = True,
                         show_final: bool = True,
                         show_trajectories: bool = None,
                         n_show: int = 1000,
                         cam_view: Tuple[float, float, float] = (45, 30, 0),
                         figsize: Tuple[int, int] = (12, 10),
                         save_path: Optional[str] = None):
        """
        Plot 3D particle positions and trajectories.
        
        Args:
            show_initial: Whether to show initial positions
            show_final: Whether to show final positions
            show_trajectories: Whether to show trajectory lines (if available)
            n_show: Maximum number of particles to show
            cam_view: Camera view parameters (azim, elev, roll)
            figsize: Figure size
            save_path: Path to save figure
        """
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection='3d')
        
        # Determine what to show
        if show_trajectories is None:
            show_trajectories = self.trajectories is not None
        
        # Sample particles to show
        n_particles = len(self.final_positions)
        if n_particles > n_show:
            indices = np.random.choice(n_particles, n_show, replace=False)
        else:
            indices = np.arange(n_particles)
        
        # Plot trajectories if available and requested
        if show_trajectories and self.trajectories is not None:
            for i in indices:
                traj = self.trajectories[i]
                ax.plot(traj[:, 0], traj[:, 1], traj[:, 2], 
                       alpha=0.4, linewidth=0.6, color='gray')
        
        # Plot initial positions
        if show_initial and self.initial_positions is not None:
            init_pos = self.initial_positions[indices]
            ax.scatter(init_pos[:, 0], init_pos[:, 1], init_pos[:, 2], 
                      c='green', s=5, label='Initial', alpha=0.7)
        
        # Plot final positions
        if show_final:
            final_pos = self.final_positions[indices]
            ax.scatter(final_pos[:, 0], final_pos[:, 1], final_pos[:, 2], 
                      c='red', s=5, label='Final', alpha=0.7)
        
        # Set camera view
        ax.view_init(azim=cam_view[0], elev=cam_view[1], roll=cam_view[2])
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.legend()
        
        title_parts = []
        if show_initial: title_parts.append("Initial")
        if show_final: title_parts.append("Final")
        if show_trajectories and self.trajectories is not None: 
            title_parts.append("Trajectories")
        
        ax.set_title(f'Particle {" & ".join(title_parts)} ({len(indices)} particles)')

        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()
    
    def plot_interactive_3d(self, 
                           show_initial: bool = True,
                           show_final: bool = True,
                           show_trajectories: bool = None,
                           n_show: int = 1000):
        """
        Create interactive 3D plot using Plotly.
        
        Args:
            show_initial: Whether to show initial positions
            show_final: Whether to show final positions  
            show_trajectories: Whether to show trajectory lines
            n_show: Maximum number of particles to show
        """
        if not PLOTLY_AVAILABLE:
            raise ImportError("Plotly is required for interactive plots")
        
        # Sample particles
        n_particles = len(self.final_positions)
        if n_particles > n_show:
            indices = np.random.choice(n_particles, n_show, replace=False)
        else:
            indices = np.arange(n_particles)
        
        fig = go.Figure()
        
        # Determine what to show
        if show_trajectories is None:
            show_trajectories = self.trajectories is not None
        
        # Add trajectories
        if show_trajectories and self.trajectories is not None:
            for i, idx in enumerate(indices):
                traj = self.trajectories[idx]
                fig.add_trace(go.Scatter3d(
                    x=traj[:, 0], y=traj[:, 1], z=traj[:, 2],
                    mode='lines',
                    name=f'Trajectory {idx}',
                    line=dict(width=2, color='gray'),
                    showlegend=False,
                    opacity=0.6
                ))
        
        # Add initial positions
        if show_initial and self.initial_positions is not None:
            init_pos = self.initial_positions[indices]
            fig.add_trace(go.Scatter3d(
                x=init_pos[:, 0], y=init_pos[:, 1], z=init_pos[:, 2],
                mode='markers',
                marker=dict(color='green', size=6),
                name='Initial Positions'
            ))
        
        # Add final positions
        if show_final:
            final_pos = self.final_positions[indices]
            fig.add_trace(go.Scatter3d(
                x=final_pos[:, 0], y=final_pos[:, 1], z=final_pos[:, 2],
                mode='markers',
                marker=dict(color='red', size=6),
                name='Final Positions'
            ))
        
        fig.update_layout(
            title=f'Interactive Particle Visualization ({len(indices)} particles)',
            scene=dict(
                xaxis_title='X',
                yaxis_title='Y',
                zaxis_title='Z'
            ),
            width=900,
            height=700
        )
        
        fig.show()
    
    def plot_displacement_analysis(self, 
                                  figsize: Tuple[int, int] = (15, 12),
                                  save_path: Optional[str] = None):
        """
        Analyze and plot particle displacements.
        
        Args:
            figsize: Figure size
            save_path: Path to save figure
        """
        if self.initial_positions is None:
            raise ValueError("Initial positions required for displacement analysis")
        
        # Calculate displacements
        displacement = self.final_positions - self.initial_positions
        displacement_magnitude = np.linalg.norm(displacement, axis=1)
        
        fig, axes = plt.subplots(2, 2, figsize=figsize)
        
        # Displacement magnitude histogram
        ax = axes[0, 0]
        ax.hist(displacement_magnitude, bins=50, alpha=0.7, edgecolor='black')
        ax.set_xlabel('Displacement Magnitude')
        ax.set_ylabel('Count')
        ax.set_title('Displacement Magnitude Distribution')
        ax.grid(True, alpha=0.3)
        
        # Displacement components
        ax = axes[0, 1]
        ax.hist(displacement[:, 0], bins=30, alpha=0.7, label='X', density=True)
        ax.hist(displacement[:, 1], bins=30, alpha=0.7, label='Y', density=True)
        ax.hist(displacement[:, 2], bins=30, alpha=0.7, label='Z', density=True)
        ax.set_xlabel('Displacement')
        ax.set_ylabel('Density')
        ax.set_title('Displacement Components')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # 2D displacement vectors (sample)
        ax = axes[1, 0]
        n_sample = min(1000, len(displacement))
        sample_idx = np.random.choice(len(displacement), n_sample, replace=False)
        
        ax.scatter(self.initial_positions[sample_idx, 0], 
                  self.initial_positions[sample_idx, 1], 
                  c='green', s=10, alpha=0.6, label='Initial')
        ax.scatter(self.final_positions[sample_idx, 0], 
                  self.final_positions[sample_idx, 1], 
                  c='red', s=10, alpha=0.6, label='Final')
        
        # Add displacement vectors (subset)
        vector_sample = sample_idx[:min(100, len(sample_idx))]
        for i in vector_sample:
            ax.arrow(self.initial_positions[i, 0], self.initial_positions[i, 1],
                    displacement[i, 0], displacement[i, 1],
                    head_width=0.01, head_length=0.01, fc='blue', ec='blue', alpha=0.3)
        
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_title('Displacement Vectors (XY Plane)')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Displacement magnitude vs distance from origin
        ax = axes[1, 1]
        initial_distance = np.linalg.norm(self.initial_positions, axis=1)
        ax.scatter(initial_distance, displacement_magnitude, alpha=0.6, s=1)
        ax.set_xlabel('Initial Distance from Origin')
        ax.set_ylabel('Displacement Magnitude')
        ax.set_title('Displacement vs Initial Position')
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()
        
        # Print statistics
        print(f"Displacement Statistics:")
        print(f"  Mean displacement: {np.mean(displacement_magnitude):.4f}")
        print(f"  Std displacement: {np.std(displacement_magnitude):.4f}")
        print(f"  Max displacement: {np.max(displacement_magnitude):.4f}")
        print(f"  Min displacement: {np.min(displacement_magnitude):.4f}")
    
    def plot_cross_sections(self, 
                           plane: str = 'xy', 
                           position: float = 0.0,
                           slab_thickness: float = 0.1,
                           show_initial: bool = True,
                           show_final: bool = True,
                           figsize: Tuple[int, int] = (12, 6),
                           save_path: Optional[str] = None,
                           grid_resolution: int = 100,
                           method: str = 'jax_kde',
                           **kwargs):
        """
        Plot cross-sections of particle positions.
        
        Args:
            plane: Cross-section plane ('xy', 'xz', 'yz')
            position: Position along the third axis for slicing
            slab_thickness: Thickness of the slice
            show_initial: Whether to show initial positions
            show_final: Whether to show final positions
            figsize: Figure size
            save_path: Path to save figure
        """
        # Define plane mappings
        plane_maps = {
            'xy': (0, 1, 2, 'X', 'Y', 'Z'),
            'xz': (0, 2, 1, 'X', 'Z', 'Y'),
            'yz': (1, 2, 0, 'Y', 'Z', 'X')
        }
        
        if plane not in plane_maps:
            raise ValueError("plane must be 'xy', 'xz', or 'yz'")
        
        axis1, axis2, axis3, label1, label2, label3 = plane_maps[plane]
        
        # Filter particles in slab
        mask = np.abs(self.final_positions[:, axis3] - position) <= slab_thickness / 2
        final_slab = self.final_positions[mask]
        
        if len(final_slab) == 0:
            raise ValueError("No particles found in the specified slab")
        
        # Calculate density
        X, Y, Z = self.calculate_density(
            positions='final',
            plane=plane,
            position=position,
            slab_thickness=slab_thickness,
            grid_resolution=grid_resolution,
            method=method,
            **kwargs
        )
        
        # Setup figure
        fig, axes = plt.subplots(2, 2, figsize=figsize)
        
        # Top-left: Final positions scatter
        ax = axes[0, 0]
        scatter = ax.scatter(final_slab[:, axis1], final_slab[:, axis2], 
                           c=final_slab[:, axis3], alpha=0.6, s=10, cmap='viridis')
        ax.set_xlabel(label1)
        ax.set_ylabel(label2)
        ax.set_title('Final Positions')
        ax.grid(True, alpha=0.3)
        ax.set_aspect('equal')
        plt.colorbar(scatter, ax=ax, label=label3)
        
        # Top-right: Density heatmap
        ax = axes[0, 1]
        contourf = ax.contourf(X, Y, Z, levels=20, cmap='plasma', alpha=0.8)
        ax.set_xlabel(label1)
        ax.set_ylabel(label2)
        ax.set_title(f'{method.upper()} Density')
        ax.grid(True, alpha=0.3)
        ax.set_aspect('equal')
        plt.colorbar(contourf, ax=ax, label='Density')
        
        # Bottom-left: Initial vs Final (if available)
        ax = axes[1, 0]
        if self.initial_positions is not None:
            initial_mask = np.abs(self.initial_positions[:, axis3] - position) <= slab_thickness / 2
            initial_slab = self.initial_positions[initial_mask]
            
            ax.scatter(initial_slab[:, axis1], initial_slab[:, axis2], 
                      c='green', alpha=0.6, s=5, label='Initial')
            ax.scatter(final_slab[:, axis1], final_slab[:, axis2], 
                      c='red', alpha=0.6, s=5, label='Final')
            ax.legend()
            ax.set_title('Initial vs Final Positions')
        else:
            ax.scatter(final_slab[:, axis1], final_slab[:, axis2], 
                      c='red', alpha=0.6, s=10)
            ax.set_title('Final Positions')
        
        ax.set_xlabel(label1)
        ax.set_ylabel(label2)
        ax.grid(True, alpha=0.3)
        ax.set_aspect('equal')
        
        # Bottom-right: Density contours
        ax = axes[1, 1]
        contour = ax.contour(X, Y, Z, levels=8, alpha=0.7, linewidths=1.0)
        ax.clabel(contour, inline=True, fontsize=8, fmt='%.3f')
        ax.scatter(final_slab[:, axis1], final_slab[:, axis2], 
                  c='black', alpha=0.1, s=1)
        ax.set_xlabel(label1)
        ax.set_ylabel(label2)
        plt.colorbar(contour, ax=ax, shrink=0.8)
        ax.set_title(f'{method.upper()} Density Contours')
        ax.grid(True, alpha=0.3)
        ax.set_aspect('equal')
        
        plt.suptitle(f'Particle Analysis ({method.upper()}) - {plane.upper()} plane at {label3}={position:.3f}', 
                     fontsize=14)
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()
    
    def plot_interactive_density(self,
                                positions: str = 'final',
                                plane: str = 'xy',
                                position: float = 0.0,
                                slab_thickness: float = 0.1,
                                method: str = 'jax_kde',
                                grid_resolution: int = 100,
                                colorscale: str = 'Plasma',
                                normalize: bool = True,
                                threshold_percent: Optional[float] = None,
                                threshold_type: str = 'percent_max',
                                show_particles: bool = True,
                                **kwargs):
        """
        Create interactive density plot using Plotly with normalization and threshold support.
        
        Args:
            positions: Which positions to use ('initial', 'final')
            plane: Cross-section plane ('xy', 'xz', 'yz')
            position: Position along the third axis for slicing
            slab_thickness: Thickness of the slice
            method: Density estimation method
            grid_resolution: Resolution of the evaluation grid
            colorscale: Plotly colorscale name
            normalize: Whether to normalize density
            threshold_percent: Threshold percentage for cutoff (None for no threshold)
            threshold_type: Type of threshold ('percent_max', 'percentile', 'absolute')
            show_particles: Whether to show particle overlay
            **kwargs: Additional parameters for density estimation
        """
        if not PLOTLY_AVAILABLE:
            raise ImportError("Plotly is required for interactive density plots")
        
        # Calculate density
        X, Y, Z = self.calculate_density(
            positions=positions,
            plane=plane,
            position=position,
            slab_thickness=slab_thickness,
            grid_resolution=grid_resolution,
            method=method,
            normalize=normalize,
            **kwargs
        )
        
        # Apply threshold if specified
        if threshold_percent is not None:
            Z_plot = self.apply_density_threshold(Z, threshold_percent, threshold_type)
        else:
            Z_plot = Z
        
        # Get plane labels
        plane_maps = {
            'xy': ('X', 'Y', 'Z'),
            'xz': ('X', 'Z', 'Y'),
            'yz': ('Y', 'Z', 'X')
        }
        label1, label2, label3 = plane_maps[plane]
        
        # Create figure
        fig = go.Figure()
        
        # Colorbar title
        density_label = "Normalized Density" if normalize else "Density"
        if threshold_percent is not None:
            density_label += f" (>{threshold_percent}% threshold)"
        
        # Add heatmap
        fig.add_trace(go.Heatmap(
            z=Z_plot,
            x=X[0, :],
            y=Y[:, 0],
            colorscale=colorscale,
            name='Density',
            hoverongaps=False,
            colorbar=dict(title=density_label)
        ))
        
        # Add particles if requested
        if show_particles:
            plane_map = {'xy': (0, 1, 2), 'xz': (0, 2, 1), 'yz': (1, 2, 0)}
            axis1, axis2, axis3 = plane_map[plane]
            
            if positions == 'final':
                pos_3d = self.final_positions
            else:
                pos_3d = self.initial_positions
                
            mask = np.abs(pos_3d[:, axis3] - position) <= slab_thickness / 2
            pos_slab = pos_3d[mask]
            
            # Sample particles for performance
            if len(pos_slab) > 1000:
                sample_idx = np.random.choice(len(pos_slab), 1000, replace=False)
                pos_slab = pos_slab[sample_idx]
            
            fig.add_trace(go.Scatter(
                x=pos_slab[:, axis1],
                y=pos_slab[:, axis2],
                mode='markers',
                marker=dict(color='black', size=2, opacity=0.5),
                name='Particles'
            ))
        
        # Update layout
        method_title = method.upper().replace('_', ' ')
        norm_title = "Normalized " if normalize else ""
        title = f'{norm_title}{method_title} Density - {plane.upper()} plane at {label3}={position:.3f}'
        if threshold_percent is not None:
            title += f' (>{threshold_percent}% threshold)'
        
        fig.update_layout(
            title=title,
            xaxis_title=label1,
            yaxis_title=label2,
            width=800,
            height=600
        )
        
        fig.show()
    
    def compare_density_methods(self,
                               plane: str = 'xy',
                               position: float = 0.0,
                               slab_thickness: float = 0.1,
                               methods: List[str] = ['jax_kde', 'sph', 'scipy_kde'],
                               figsize: Tuple[int, int] = (18, 6),
                               normalize: bool = True,
                               threshold_percent: Optional[float] = None,
                               save_path: Optional[str] = None,
                               **kwargs):
        """
        Compare different density estimation methods side by side with normalization.
        
        Args:
            plane: Cross-section plane ('xy', 'xz', 'yz')
            position: Position along the third axis for slicing
            slab_thickness: Thickness of the slice
            methods: List of methods to compare
            figsize: Figure size
            normalize: Whether to normalize density
            threshold_percent: Threshold percentage (None for no threshold)
            save_path: Path to save figure
            **kwargs: Additional parameters for density estimation
        """
        n_methods = len(methods)
        fig, axes = plt.subplots(1, n_methods, figsize=figsize)
        if n_methods == 1:
            axes = [axes]
        
        for i, method in enumerate(methods):
            try:
                X, Y, Z = self.calculate_density(
                    plane=plane,
                    position=position,
                    slab_thickness=slab_thickness,
                    method=method,
                    normalize=normalize,
                    **kwargs
                )
                
                # Apply threshold if specified
                if threshold_percent is not None:
                    Z = self.apply_density_threshold(Z, threshold_percent, 'percent_max')
                
                ax = axes[i]
                contourf = ax.contourf(X, Y, Z, levels=15, cmap='viridis', alpha=0.8)
                
                # Colorbar label
                density_label = "Normalized Density" if normalize else "Density"
                if threshold_percent is not None:
                    density_label += f" (>{threshold_percent}%)"
                
                plt.colorbar(contourf, ax=ax, label=density_label)
                
                method_title = method.upper().replace('_', ' ')
                norm_title = "Normalized " if normalize else ""
                title = f'{norm_title}{method_title}'
                if threshold_percent is not None:
                    title += f' (>{threshold_percent}%)'
                
                ax.set_title(title)
                ax.set_xlabel('X' if plane == 'xy' else ('X' if plane == 'xz' else 'Y'))
                ax.set_ylabel('Y' if plane == 'xy' else ('Z' if plane == 'xz' else 'Z'))
                ax.set_aspect('equal')
                ax.grid(True, alpha=0.3)
                
            except Exception as e:
                axes[i].text(0.5, 0.5, f'Error with {method}:\n{str(e)}', 
                            ha='center', va='center', transform=axes[i].transAxes)
                axes[i].set_title(f'{method.upper()} (Error)')
        
        suptitle = f'Density Method Comparison - {plane.upper()} plane at position={position:.3f}'
        if normalize:
            suptitle = "Normalized " + suptitle
        plt.suptitle(suptitle)
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()

    def plot_density_threshold_comparison(self,
                                        plane: str = 'xy',
                                        position: float = 0.0,
                                        slab_thickness: float = 0.1,
                                        method: str = 'jax_kde',
                                        thresholds: List[float] = [10, 25, 50],
                                        figsize: Tuple[int, int] = (18, 6),
                                        normalize: bool = True,
                                        save_path: Optional[str] = None,
                                        **kwargs):
        """
        Compare different threshold levels for density visualization.
        
        Args:
            plane: Cross-section plane ('xy', 'xz', 'yz')
            position: Position along the third axis for slicing
            slab_thickness: Thickness of the slice
            method: Density estimation method
            thresholds: List of threshold percentages to compare
            figsize: Figure size
            normalize: Whether to normalize density
            save_path: Path to save figure
            **kwargs: Additional parameters for density estimation
        """
        # Calculate base density once
        X, Y, Z = self.calculate_density(
            plane=plane,
            position=position,
            slab_thickness=slab_thickness,
            method=method,
            normalize=normalize,
            **kwargs
        )
        
        n_plots = len(thresholds) + 1  # +1 for no threshold
        fig, axes = plt.subplots(1, n_plots, figsize=figsize)
        if n_plots == 1:
            axes = [axes]
        
        # Plot without threshold
        ax = axes[0]
        im = ax.imshow(Z, extent=[X.min(), X.max(), Y.min(), Y.max()], 
                      origin='lower', cmap='viridis', aspect='equal')
        
        density_label = "Normalized Density" if normalize else "Density"
        plt.colorbar(im, ax=ax, label=density_label)
        ax.set_title('No Threshold')
        ax.set_xlabel('X' if plane == 'xy' else ('X' if plane == 'xz' else 'Y'))
        ax.set_ylabel('Y' if plane == 'xy' else ('Z' if plane == 'xz' else 'Z'))
        ax.grid(True, alpha=0.3)
        
        # Plot with different thresholds
        for i, threshold in enumerate(thresholds):
            ax = axes[i + 1]
            Z_thresh = self.apply_density_threshold(Z, threshold, 'percent_max')
            
            im = ax.imshow(Z_thresh, extent=[X.min(), X.max(), Y.min(), Y.max()], 
                          origin='lower', cmap='viridis', aspect='equal')
            
            thresh_label = f"Density (>{threshold}%)"
            plt.colorbar(im, ax=ax, label=thresh_label)
            ax.set_title(f'>{threshold}% Threshold')
            ax.set_xlabel('X' if plane == 'xy' else ('X' if plane == 'xz' else 'Y'))
            ax.set_ylabel('Y' if plane == 'xy' else ('Z' if plane == 'xz' else 'Z'))
            ax.grid(True, alpha=0.3)
        
        method_title = method.upper().replace('_', ' ')
        norm_title = "Normalized " if normalize else ""
        suptitle = f'{norm_title}{method_title} Density Threshold Comparison - {plane.upper()} plane'
        plt.suptitle(suptitle)
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()
    
    def export_to_vtk(self,
                     output_directory: str = "vtk_output",
                     base_filename: str = "particle_results",
                     include_density: bool = True,
                     density_params: Optional[Dict] = None,
                     time_value: Optional[float] = None) -> Dict[str, str]:
        """
        Export particle tracking results to VTK format for ParaView.
        
        Args:
            output_directory: Directory to save VTK files
            base_filename: Base filename for all outputs
            include_density: Whether to calculate and export density field
            density_params: Parameters for density calculation
            time_value: Time value for the final state
            
        Returns:
            Dictionary mapping data type to saved file path
        """
        try:
            from .exporter import VTKExporter
        except ImportError:
            raise ImportError("VTKExporter not available. Please check exporter module.")
        
        # Create VTK exporter
        exporter = VTKExporter(output_directory)
        
        # Prepare density data if requested
        density_data = None
        if include_density:
            if density_params is None:
                density_params = {
                    'plane': 'xy',
                    'position': 0.0,
                    'slab_thickness': 0.5,
                    'method': 'jax_kde' if JAX_AVAILABLE else 'scipy_kde',
                    'grid_resolution': 100
                }
            
            try:
                X, Y, Z = self.calculate_density(
                    positions='final',
                    **density_params
                )
                
                density_data = {
                    'X': X,
                    'Y': Y, 
                    'density': Z,
                    'dimensions': '2d',
                    'plane': density_params.get('plane', 'xy'),
                    'position': density_params.get('position', 0.0)
                }
                print("Calculated density field for export")
                
            except Exception as e:
                print(f"Warning: Could not calculate density field: {e}")
                include_density = False
        
        # Export complete simulation
        saved_files = exporter.export_complete_simulation(
            positions=self.final_positions,
            base_filename=base_filename,
            initial_positions=self.initial_positions,
            trajectories=self.trajectories,
            dimensions='3d',  # Default to 3D export
            time_value=time_value,
            calculate_density=include_density,
            density_method=density_params.get('method', 'jax_kde') if density_params else 'jax_kde'
        )
        
        print(f"\nVTK Export Summary:")
        print(f"Output directory: {output_directory}")
        print(f"Files created:")
        for data_type, filepath in saved_files.items():
            print(f"  {data_type}: {filepath.split('/')[-1]}")
        
        print(f"\nTo load in ParaView:")
        print(f"1. Open ParaView")
        print(f"2. File -> Load State -> {base_filename}_state.pvsm")
        print(f"3. Or manually load individual .vtp/.vti files")
        
        return saved_files
    
    @staticmethod
    def create_density_colormap(base_color: str = 'viridis', 
                               n_colors: int = 256,
                               alpha_min: float = 0.0,
                               alpha_max: float = 1.0) -> LinearSegmentedColormap:
        """
        Create a custom colormap for density plots with transparency.
        
        Args:
            base_color: Base colormap name or single color
            n_colors: Number of colors in the colormap
            alpha_min: Minimum alpha (transparency) value
            alpha_max: Maximum alpha value
            
        Returns:
            Custom colormap with transparency gradient
        """
        if isinstance(base_color, str) and base_color in plt.colormaps():
            # Use existing colormap as base
            base_cmap = plt.get_cmap(base_color)
            colors = base_cmap(np.linspace(0, 1, n_colors))
        else:
            # Create colormap from single color
            if isinstance(base_color, str):
                # Convert color name to RGB
                base_rgb = mcolors.to_rgb(base_color)
            else:
                base_rgb = base_color
            
            # Create gradient from white to base color
            colors = np.zeros((n_colors, 4))
            for i in range(n_colors):
                t = i / (n_colors - 1)
                # Interpolate from white to base color
                colors[i, :3] = (1 - t) * np.array([1, 1, 1]) + t * np.array(base_rgb)
                colors[i, 3] = 1.0  # Full alpha initially
        
        # Apply alpha gradient
        alphas = np.linspace(alpha_min, alpha_max, n_colors)
        colors[:, 3] = alphas
        
        return ListedColormap(colors)
    
    def get_visualization_info(self) -> Dict:
        """
        Get comprehensive information about the visualizer state.
        
        Returns:
            Dictionary containing visualizer information
        """
        info = {
            'n_particles': len(self.final_positions),
            'has_initial_positions': self.initial_positions is not None,
            'has_trajectories': self.trajectories is not None,
            'final_position_bounds': {
                'x': (float(np.min(self.final_positions[:, 0])), float(np.max(self.final_positions[:, 0]))),
                'y': (float(np.min(self.final_positions[:, 1])), float(np.max(self.final_positions[:, 1]))),
                'z': (float(np.min(self.final_positions[:, 2])), float(np.max(self.final_positions[:, 2])))
            },
            'jax_available': JAX_AVAILABLE,
            'plotly_available': PLOTLY_AVAILABLE
        }
        
        if self.initial_positions is not None:
            info['initial_position_bounds'] = {
                'x': (float(np.min(self.initial_positions[:, 0])), float(np.max(self.initial_positions[:, 0]))),
                'y': (float(np.min(self.initial_positions[:, 1])), float(np.max(self.initial_positions[:, 1]))),
                'z': (float(np.min(self.initial_positions[:, 2])), float(np.max(self.initial_positions[:, 2])))
            }
        
        if self.trajectories is not None:
            info['trajectory_shape'] = self.trajectories.shape
            info['n_timesteps'] = self.trajectories.shape[1]
        
        return info
    
    def __repr__(self) -> str:
        """String representation of the ParticleVisualizer."""
        parts = [f"ParticleVisualizer(n_particles={len(self.final_positions)}"]
        
        if self.initial_positions is not None:
            parts.append("has_initial=True")
        if self.trajectories is not None:
            parts.append(f"has_trajectories=True, n_steps={self.trajectories.shape[1]}")
        
        return ", ".join(parts) + ")"


# Convenience functions for quick visualization
def quick_visualize_positions(final_positions: np.ndarray,
                             initial_positions: Optional[np.ndarray] = None,
                             trajectories: Optional[np.ndarray] = None,
                             mode: str = '3d',
                             **kwargs):
    """
    Quick visualization function for particle positions.
    
    Args:
        final_positions: Final particle positions (N, 3)
        initial_positions: Initial particle positions (N, 3), optional
        trajectories: Full trajectories (N, n_steps, 3), optional
        mode: Visualization mode ('3d', 'cross_section', 'density', 'analysis')
        **kwargs: Additional arguments for the visualization method
    """
    viz = ParticleVisualizer(final_positions, initial_positions, trajectories)
    
    if mode == '3d':
        viz.plot_3d_positions(**kwargs)
    elif mode == 'interactive_3d':
        viz.plot_interactive_3d(**kwargs)
    elif mode == 'cross_section':
        viz.plot_cross_sections(**kwargs)
    elif mode == 'density':
        viz.plot_density(**kwargs)
    elif mode == 'analysis':
        viz.plot_combined_analysis(**kwargs)
    elif mode == 'displacement':
        viz.plot_displacement_analysis(**kwargs)
    elif mode == 'density_threshold':
        viz.plot_density_with_threshold(**kwargs)
    elif mode == 'compare_methods':
        viz.compare_density_methods(**kwargs)
    elif mode == 'compare_thresholds':
        viz.plot_density_threshold_comparison(**kwargs)
    else:
        raise ValueError("mode must be one of: '3d', 'interactive_3d', 'cross_section', 'density', "
                        "'analysis', 'displacement', 'density_threshold', 'compare_methods', 'compare_thresholds'")


def compare_density_methods(final_positions: np.ndarray, **kwargs):
    """
    Convenience function for comparing density methods.
    
    Args:
        final_positions: Final particle positions (N, 3)
        **kwargs: Arguments passed to ParticleVisualizer.compare_density_methods()
    """
    viz = ParticleVisualizer(final_positions=final_positions)
    viz.compare_density_methods(**kwargs)


def plot_density_threshold_comparison(final_positions: np.ndarray, **kwargs):
    """
    Convenience function for comparing density thresholds.
    
    Args:
        final_positions: Final particle positions (N, 3)
        **kwargs: Arguments passed to ParticleVisualizer.plot_density_threshold_comparison()
    """
    viz = ParticleVisualizer(final_positions=final_positions)
    viz.plot_density_threshold_comparison(**kwargs)


# Export main classes and functions
__all__ = [
    'ParticleVisualizer',
    'quick_visualize_positions',
    'compare_density_methods',
    'plot_density_threshold_comparison'
]